# goroutine背后的系统知识
### 1. 操作系统与运行库
#### 系统调用
除了内存管理，文件管理，进程管理，外设管理等内部模块外，操作系统还提供了许多外部接口供应用程序使用，也就是所谓的"系统调用"。  
- 软中断  
  DOS时代开始，系统调用就是通过软中断的形式来提供，也就是著名的INT21，程序吧需要调用的功能编号放入AH寄存器，把参数放入其他指定的寄存器，然后调用INT21，中断返回后，程序从指定的寄存器(通常是AL)里取得返回值。linux则是INT80  
我们写程序并不需要调用中断或者SYSCALL指令，这是因为操作系统提供了一层封装，在Window上，它是NTDLL.DLL，也就是常说的Native API  
Linxu上的封装是VDOS  

- 运行库  
我们写程序的时候也很少调用NTDLL或者VDSO，而是更上一层的封装，这一层处理了参数准备和返回值格式转换，以及出错处理和错误代码转换，这就是我们所使用语言的运行库，对于C语言，Linux上是glibc，Windows上是kernel32（或nsvcrt），对于其他语言而言，Java的JRE，这些语言的运行库通常最终还是glibc或kernel32  
"运行库"不止包括用于和编译后的目标执行程序进行链接的库文件，也包括了脚本语言或字节码解释型语言的运行环境，如Python，C#的CLR，Java的JRE  

对系统调用的封装只是运行库的很小一部分功能，运行库通常还提供了诸如字符串处理，数学计算，常用数据结构容器等等不需要操作系统支持的功能，同时，运行库也会对操作系统支持的功能提供更易用更高级的封装，比如带缓存和格式的IO，线程池  

#### 2. 线程的调度
- IA-32 CPU的指令控制方式  
CPU通过CS:EIP寄存器的值确定下一条指令的位置，但是CPU并不允许直接使用MOV指令来更改EIP的值，必须通过JMP系列指令，CALL/RET指令，或者INT中断指令来实现代码的跳转，在指令序列间切换的时候，处理更改EIP之外，我们还要保证代码可能会使用到各个寄存器的值，尤其是栈指针SS:ESP，以及EFLAGS标志位等，都能够恢复到目标指令序列上次执行到这个位置时候的状态  

- 线程
线程是操作系统对外提供的服务，应用程序可以通过系统调用来让操作系统启动线程，并负责随后的线程调度和切换。



# 