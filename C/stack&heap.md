# 堆和栈的区别
## 一个C/C++编译的程序占用的内存分下面几个部分  
1. 栈区(stack)： 由'编译器自动分配释放'，存放函数的参数值，局部变量等。操作方式类似于数据结构中的栈  
2. 堆区(heap)： 一般由'程序员分配释放'，若不释放，程序结束后可能由OS回收。它与数据结构中的堆是两回事，分配方式类似于链表  
3. 全局区(静态区)(static)： 全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后'由系统释放'  
4. 文字常量区： 常量字符串就在这里，程序结束后由系统释放  
5. 程序代码区： 存放函数体的二进制代码  

## 例子程序
```c
// main.cpp
int a = 0;                    // 全局初始化区
char *p1;                     // 全局未初始化区
main()
{
  int b;                      // 栈
  char s[] = "abc"            // 栈
  char * p2;                  // 栈
  char * p3 = "123456";       //123456 在常量区，p3在栈上
  static int c = 0;           // 全局（静态）初始化区
  p1 = (char * )malloc(10);
  p2 = (char * )malloc(20);
                              // 分配得来的10和20字节的区域就在堆区
  strcpy(p1, "123456");       // 123456 放在常量区，编译器可能会将它与p3所指向的"123456"优化成一个地方
}
```
## 堆和栈的理论知识
#### 申请方式
- stack: 由系统自动分配
  ```c
  int b; // 系统自动在栈中为b开辟空间
  ```
- heap: 程序员自己申请，并指明大小  
  ```c
  // 在C中用malloc函数
  p1 = (char * )malloc(10);
  // C++中使用new运算符
  p2 = new char[10];
  // 注意：p1 p2本身是在栈中的
  ```

#### 申请后系统的响应
- 栈：只要栈的剩余空间大于所申请的控件，系统将为程序提供内存，否则将报异常提示栈溢出  
- 堆：首先应该知道，操作系统有一个记录空闲内存地址的链表，当系统受到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的控件分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码的delete语句才能正确的释放本内存控件。  
  另外，由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动将多余的那部分重新放入空闲链表中  

#### 申请大小的限制
- 栈：在windows下，栈是向低地址扩展的数据结构，是一块连续的内存区域，较小
- 堆：是向高地址扩展的数据结构，是不连续的内存区域，较大  

#### 堆和栈中的存储内容
- 堆：在函数调用时，第一个进栈的是主函数中的下一条指令(函数调用语句的下一条可执行语句)的地址，然后是函数的各个参数，在大多数C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。静态变量不入栈  
  当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行  
- 堆：一般是在堆的头部用一个字节存放堆的大小。堆中具体内容由程序员安排  
