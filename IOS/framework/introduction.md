# iOS客户端架构
> [iOS应用架构谈 开篇](https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html)

#### 架构要考虑的事情(App)
  - 调用网络API  
    > 如何让业务开发工程师方便安全的调用网络API，然后尽可能保护用户在各种网络环境下都有良好的体验  

  - 页面展示  
    > 页面如何组织，才能尽可能降低业务方代码的耦合度，尽可能降低业务方开发界面的复杂度，提高效率  

  - 数据的本地持久化
    > 当数据有在本地存取的需求时，如何能够保证数据在本地的合理安排，尽可能的缩小性能消耗  

  - 动态部署方案  
    > iOS应用有审核期，如何能够通过不发版本的方式展示新的内容给用户，如何修复紧急BUG  

#### 架构要考虑的事情(团队)  
  - 收集用户数据，给产品和运营参考  
  - 合理的组织各业务方开发的业务模块，以及相关基础模块  
  - 每日app的自动打包，提供给QA工程师的测试工具  

### 主要讨论的问题
  1. 网络层设计方案，设计网络层是要考虑的问题，网络层优化的时候，可以从哪些方面入手  
  2. 页面的展示、调用和组织都有哪些设计方案，需要考虑哪些问题  
  3. 本地持久化的设计方案有哪些？优劣是什么？不同方案间要注意的问题分别是什么  
  4. 要实现动态部署，都有哪些方案？不同方案之间的优劣，侧重？

### 架构设计的方法
##### 第一步：搞清楚要解决哪些问题，并找到解决这些问题的充要条件    
 > tips: 传的参数越少，耦合度相对而言就与越小，替换模块或者升级模块所话费的代价就越小  

##### 第二步：问题分类，分模块  
##### 第三步：搞清楚各问题之间的依赖关系，建立好模块交流规范并设计模式  
关键在于建立一套统一的交流规范。这一步很能够体现架构师在软件方面的价值观，虽然存在一定程度上的好坏优劣（如胖Model和瘦Model）  
一定要建立一套同意的交流规范。
##### 第四步：推演预测一下未来可能的走向，必要时添加新的模块，记录更多的基础数据以备未来之用  
##### 第五步：先解决依赖关系中最基础的问题，实现基础模块，然后再用基础模块堆叠出整个架构  
##### 第六步：打点，跑单元测试，跑性能测试，根据数据去优化对应的地方  
需要遵循的原则：**自顶向下设计**(1,2,3,4步)，**自底向上实现**(5)，**先测量后优化**(6)

### 什么样的架构师是好架构师  
1. 每天学习  
2. 业务出身或者熟悉公司业务  
3. 熟悉软件工程的各种规范，踩过无数坑  
4. 及时承认错误    

### 什么样的架构叫好架构
1. 代码整齐，分类明确，没有common，没有core  
2. 不用文档，或很少文档，就能让业务方上手  
3. 思路和方法要统一，尽量不要多元  
4. 没有横向依赖，万不得已不出现跨层访问  
5. 对业务方该限制的地方有限制，该灵活的地方要给业务方创造灵活实现的条件  
6. 易测试，易扩展  
7. 保持一定量的超前性  
8. 接口少，接口参数少  
9. 高性能  

##### 1. 代码整齐，分类明确，没有common，没有core（...）  
- 代码整齐是一个工程师的基本素质，破窗理论提醒我们，如果代码不整齐，分类不明确，整个架构会随着一次次拓展而越来越混乱     
- 不要让一个类或者一个模块做两种不同的事情，这样会给拓展和分类造成困难   
- 不要搞common，core这些东西，随着版本的迭代，common会变得不common，core也不core。如果真的有什么东西特别小，那就索性为他单独开辟一个模块就好了  

##### 2. 不用文档，或很少文档就能让业务方上手（我觉得文档还是需要的，不管接口写的多好...）  
- 如果能把API的名字设计的可读性很强，那么就可以让文档不那么必要
```objective-c
// 好的函数名
- (BSDictionary * )exifDataOfImage:(UIImage * )image atIndexPath:(NSIndexPath * )indexPath;
// 坏的函数名
- (id)exifData:(UIImage * )image position:(id)indexPath callBack:(id<ErrorDelegate>)delegate;

/*
为什么坏：
1. 不要直接返回id或者传入id，实在不行，用id<protocol>也比id好
2. 要告知业务传入的是什么东西，比如要传image，那就写上ofImage。如果要穿位置，那就写上IndexPath，而不是用position这么笼统的东西
3. 没有任何理由要把delegate作为参数传进去，一定不会有任何情况不得不这么做的。而且delegate这个参数根本不是这个函数要解决的问题的充要条件
*/
```

##### 3. 思路和方法要统一，尽量不要多元（不要灵光一闪，可是有了更好的思路，还是值得的...）
- 解决一个问题会有很多方案，但是一旦确定一个方案，就不要在另一个地方采用别的方案了。做架构的时候，得时刻记住当初决定要处理这类问题的方案是什么，以及初衷，不要摇摆不定。  
- 当初设立这个模块一定是有想法有原因的，应该记录下解决思路，不要到时候换个地方灵光一闪啥的，引入其他方案，从而导致异构  

##### 4. 没有横向依赖，万不得已不出现跨层访问（）  
- 没有横向依赖是很重要的，这决定了将来对这个架构做修补所需要的成本有多大，要做到没有横向依赖，要有一定的模块分类能力和业务的熟悉度  
跨层访问是指数据流向了和自己没有对接关系的模块。  
> 有的时候跨层访问是不可避免的，比如网络底层信号从2G变成了3G，这时有可能需要跨层通知到View。一旦出现就要尽量在本层搞定或者交给上层或者下层搞定，尽量不要出现跨层的情况。  
##### 5. 对业务方改限制的限制，该灵活的给创造灵活的条件  
- 需要区分哪些情况需要限制灵活性，比如：  
> 对于Core Data技术栈来说，ManagerObject理论上可以出现在任何地方，那就意味着任何地方都可以修改ManagedObject，这就导致ManagedObjectContext在同步修改的时候把各种不同来源的修改同步进去。这时候就需要限制灵活性，只对外公开一个修改接口，不暴露任何managedObject在外面  
- 提供灵活性的情况：  
> 如果是设计一个ABTest相关的Api时，就可以增加它的灵活性，使得业务方不光可以通过Target-Action的模式实现ABTest，也要可以通过Block的方式实现ABTest，尽可能满足灵活性   

##### 6. 易用性扩展  
要实现易测试扩展，那就提高模块化成都，尽可能减少依赖关系，便于mock测试。  
如果是高度模块化的架构，拓展起来将会是一件非常容易的事  

##### 7. 保持一定量的超前性  
保持对技术和产品的最新动态的关注  

##### 8. 接口少，参数少  
越少的接口越少的参数，就能降低业务方的使用成本  

##### 9. 高性能  
高性能非常重要，但是在客户端架构中，他不是第一要素  
原因：  
- 客户端业务变化非常之快，做架构时首要考虑因素应该是便于业务方快速满足产品需求，因此需要竟可能提供简单易用效果好的接口给业务方  
- 苹果平台的性能非常之棒，正常情况下都不会出现由于性能不够导致用户体验的问题  
- 苹果平台优化手段有限  
但是网络层啥的还是要优化的  


### 架构分层  
##### 常见的分层架构：三层和四层  
- 三层： 展现层、业务层、数据层  
- 四层： 展现层、业务层、网络层、数据层  

#### 常见架构：MVC、MVVM  
这种层次划分，主要是针对数据流动的方向而言的  
而三层架构不是MVC......  

#### 那如何分层  
如何分层不是做架构的时候一开始就考虑的问题。虽然我们要按照自顶向下的设计方式来设计架构，但是一般情况下不适合直接从三层开始。  
1. 一般都是先确定所要解决的问题，先确定都有哪些模块  
2. 然后再基于这些模块往下细化设计  
3. 然后再把这些写列出来的问题和模块做好分类  
分类之后不出意外都是三层，如果一层特别大就可以拆开变成四层，五层  
> 举个例子：及时通讯的服务端架构  
> 先列出问题：  
>   1. 用户登录、退出  
>   2. 解决不同用户间数据交流的问题  
>   3. 解决用户数据存储问题  
>   4. 如果是多台服务器的集群，就要解决用户连接的寻址问题  
> 1. 第一个问题：  
>    需要一个链接管理模块，链接管理模块一般是通过连接池来实现。
> 2. 第二个问题：  
>    需要一个数据交换模块，从A接收来的诗句要给到B，这个事情由这个模块来做  
> 3. 第三个问题：  
>    需要有个数据库，如果是服务于大量用户，那么久需要一个缓冲区，只有当需要存储的数据达到一定量是才执行写操作  
> 4. 第四个问题：  
>    可以有几种解决方案，一个是集群中有那么几台服务器作为寻路服务器，所有寻路的服务交给那几台去做；要么开发一个寻路服务的Daemon；或者用广播的方式寻址，但如果寻路频次非常高，会赵成集群内部网络负载特别大。目前流行的思想是去中心化，那么要解决网络负载的问题，这就可以配置一个缓存  
> 根据以上问题，就有了以下模块：链接管理、数据交换、数据库及其配套模块、寻路模块  
> --这虽然是服务器架构，但是和客户端架构差不多，只是侧重点不同而已--
